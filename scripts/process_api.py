# Need androguard from master, along with a patch
import argparse
import json
import pickle
import resource
import sys
from collections import defaultdict
from json import JSONEncoder
from pathlib import Path
from typing import List, Dict

import androguard.core.analysis.analysis as analysis
import networkx as nx
from androguard.core.bytecode import FormatClassToJava
from androguard.misc import AnalyzeAPK

# https://stackoverflow.com/questions/2134706/hitting-maximum-recursion-depth-using-pickle-cpickle
max_rec = 0x100000
resource.setrlimit(resource.RLIMIT_STACK, (0x100 * max_rec, resource.RLIM_INFINITY))
sys.setrecursionlimit(max_rec)


class SetEncoder(JSONEncoder):
    def default(self, obj):
        return list(obj)


def get_inheritance_graph(dx: analysis.Analysis) -> nx.classes.digraph.DiGraph:
    """
    Gets inheritance graph from dx returned from AnalyzeAPK
    Inheritance graph G is a DAG, where (parent, child) relationship between
    the classes are represented as directed edges
    :param dx: Analysis object returned from AnalyzeAPK
    :return: networkx directed graph
    """
    classes: List[analysis.ClassAnalysis] = list(dx.find_classes(no_external=True))
    inheritance_tree = nx.DiGraph()
    for class_ in classes:
        for parent in [class_.extends, *class_.implements]:
            inheritance_tree.add_edge(str(parent), str(class_.name))
    for node in inheritance_tree.nodes():
        # If a node has no parent (because it is external), Ljava/lang/Object; is made as its parent
        if len(inheritance_tree.pred[node]) == 0 and node != 'Ljava/lang/Object;':
            inheritance_tree.add_edge('Ljava/lang/Object;', node)
            assert len(inheritance_tree.pred[node]) == 1
    return inheritance_tree


def get_access_flags(class_or_method):
    access_flags = class_or_method.get_access_flags_string()
    to_find = ['public', 'static', 'final', 'protected', 'constructor', 'interface']
    return {
        f'is_{x}': (x in access_flags) for x in to_find
    }


def get_access_flags_dict(dx):
    classes: List[analysis.ClassAnalysis] = list(dx.find_classes(no_external=True))
    result = {}
    for class_ in classes:
        class_access_flags = get_access_flags(class_.get_class())
        result[str(class_.name)] = ' '.join([x[3:] for x, y in class_access_flags.items() if y])
    return result


def get_method_names(dx):
    method_names = defaultdict(set)
    for class_ in dx.classes.values():
        if class_.is_external() or 'public' in get_access_flags(class_.get_class()):
            for method in class_.get_methods():
                if method.is_external() or 'public' in get_access_flags(method):
                    method_names[str(class_.name)].add(str(method.name))
    return method_names


def get_argument_graph(dx: analysis.Analysis, public_only=True) -> nx.classes.digraph.DiGraph:
    """
    Gets argument graph from dx returned from AnalyzeAPK
    Argument graph is a Directed graph, where (function, parameter class)
    relationship is expressed as the edges of the graph for all public functions
    :param dx: Analysis object returned from AnalyzeAPK
    :param public_only: Whether to consider only public methods, by default True
    :return: networkx directed graph
    """
    usage_graph = nx.DiGraph()
    classes: List[analysis.ClassAnalysis] = list(dx.find_classes(no_external=True))
    for class_ in classes:
        class_access_flags = get_access_flags(class_.get_class())
        for method in class_.get_methods():
            if not method.is_external():
                method_access_flags = get_access_flags(method)
                encoded_method = method.get_method()
                parameter_types = [str(x[1]) for x in encoded_method.get_information().get('params', [])]
                consider = (class_access_flags['is_public'] and method_access_flags['is_public']) or not public_only
                if consider:
                    for parameter_type in parameter_types:
                        usage_graph.add_edge(
                            FormatClassToJava(parameter_type),
                            f'{method.class_name}#{method.name}#{method.descriptor}'
                        )
    return usage_graph


def get_potential_api_callbacks(dx: analysis.Analysis) -> List[analysis.MethodAnalysis]:
    """
    A potential callback class is a class in Framework Space which can be overriden in Application Space
    That means, Following conditions must be satisfied
    1. It must be public and not final
    2. It should contain at least one public constructor or it is an interface
    A method in potential callback class is a potential callback method if
    1. It is either public or protected
    :param dx: Analysis object returned from AnalyzeAPK
    :return: List of names of potential callback methods
    """
    potential_callback_methods = []
    classes: List[analysis.ClassAnalysis] = list(dx.find_classes(no_external=True))
    for class_ in classes:
        class_access_flags = get_access_flags(class_.get_class())
        class_has_public_constructor = False
        potential_methods = []
        for method in class_.get_methods():
            if not method.is_external():
                method_access_flags = get_access_flags(method)
                if method_access_flags['is_public'] and method_access_flags['is_constructor']:
                    class_has_public_constructor = True
                if method_access_flags['is_public'] or \
                        method_access_flags['is_protected'] or \
                        class_access_flags['is_interface']:
                    potential_methods.append(method)
        if class_access_flags['is_public'] and \
                not class_access_flags['is_final'] and \
                (class_has_public_constructor or class_access_flags['is_interface']):
            potential_callback_methods += potential_methods
    return potential_callback_methods


def filter_potential_callbacks(potential_callback_methods: List[analysis.MethodAnalysis],
                               argument_graph: nx.DiGraph) -> List[Dict[str, str]]:
    """
    Filters potential callbacks to obtain the final callbacks.
    A callback M of class C is a final iff
    1. If C is a parameter to a application space accessible method U of class X
        (This means X and U both are public)
    2. Some method(s) Z of U calls M in its code
    Then,
    X.U is termed as a registration method of callback class C
    A usage pair X.Z -> C.M is added to the result
    :param potential_callback_methods: Result of :func:`get_potential_api_callbacks`
    :param argument_graph: Result of :func:`get_argument_graph`
    :return: List of dict, keyed by (C, X) and containing set of registration methods U
    and registration callback pairs X.Z -> C.M
    """
    # First, potential callbacks methods M are mapped to their classes C, {C->{M}}
    final_callback_classes = defaultdict(set)
    for method in potential_callback_methods:
        if method.class_name in argument_graph:
            final_callback_classes[method.class_name].add(method)
    # The container for dicts of result
    result = []
    for callback_class in final_callback_classes:
        # Current class result
        callback_class_result = {
            'callback_class': str(callback_class),  # C
            'used_classes': {}
        }
        # The methods in callback class that can be overridden, {M}
        potential_methods = final_callback_classes[callback_class]
        # The methods in which potential_callback_class is used
        # Used class -> Used method mapping, {X -> {U}}
        usages = defaultdict(set)
        for usage in argument_graph[callback_class]:
            method = dx.get_method_analysis_by_name(*usage.split('#'))
            class_ = dx.get_class_analysis(method.class_name)
            method_access_flags = get_access_flags(method)
            class_access_flags = get_access_flags(class_.get_class())
            if method_access_flags['is_public'] and class_access_flags['is_public']:
                usages[class_].add(method)

        for potential_method in potential_methods:
            xrefs = list(potential_method.get_xref_from())
            xref_classes = [x[0] for x in xrefs]
            final_used_classes = set(xref_classes).intersection(set(usages))
            for final_used_class in final_used_classes:
                registration_methods = usages[final_used_class]
                final_used_class_name = str(final_used_class.name)
                used_class_result = callback_class_result['used_classes'].get(final_used_class_name, {
                    'registration_methods': set(),
                    'used->callback mapping': set()
                })
                for x in registration_methods:
                    used_class_result['registration_methods'].add(str(x.full_name))
                for used_class, used_method, _ in xrefs:
                    if used_class.name == final_used_class.name:
                        used_class_result['used->callback mapping'].add(
                            (str(used_method.full_name),
                             str(potential_method.full_name))
                        )
                if final_used_class_name not in callback_class_result:
                    callback_class_result['used_classes'][final_used_class_name] = used_class_result
        if len(callback_class_result['used_classes']) > 0:
            result.append(callback_class_result)
    return result


if __name__ == '__main__':
    parser = argparse.ArgumentParser(description='Process framework.jar to extract callbacks.')
    parser.add_argument('--input', help='The path of the framework.jar')
    parser.add_argument('--no-cache', help='Use cache if framework.jar has already been processed', action='store_true', default=False)
    parser.add_argument('--output-dir', help='The directory to store the result', required=True)
    args = parser.parse_args()
    source_path = Path(args.input)
    if not source_path.exists():
        raise FileNotFoundError(f"{source_path} doesn't exist")
    source_dir = source_path.parent
    if args.no_cache or not (source_dir / 'dx.pkl').exists():
        print(f"Ignoring cache and processing {source_path}")
        _, _, dx = AnalyzeAPK(source_path)
        pickle.dump(dx, open(source_dir / "dx.pkl", "wb"))
    else:
        print("Found cache, loading it.")
        dx = pickle.load(open(source_dir / "dx.pkl", "rb"))
    print(f"Successfully loaded dx with {len(dx.methods)} methods and {len(dx.classes)} classes.")
    print("Calculating argument graph.")
    argument_graph = get_argument_graph(dx)
    print("Calculating inheritance graph.")
    inheritance_graph = get_inheritance_graph(dx)
    print("Calculating potential callbacks.")
    potential_callbacks = get_potential_api_callbacks(dx)
    print(f"{len(potential_callbacks)} potential callbacks found.")
    print("Calculating final callbacks.")
    final_callbacks = filter_potential_callbacks(potential_callbacks, argument_graph)
    print(f"Final callbacks were found belonging to {len(final_callbacks)} callback class - registration class pairs.")
    access_flags_dict = get_access_flags_dict(dx)
    method_names = get_method_names(dx)
    print(f"Writing results to {args.output_dir}")
    output_dir = Path(f"{args.output_dir}/api_analysis")
    if not output_dir.exists():
        print(f"{output_dir} doesn't exist. Creating")
        Path.mkdir(output_dir, parents=True)
    json.dump(
        nx.readwrite.json_graph.node_link_data(argument_graph),
        open(output_dir / "argument_graph.json", "w"),
        cls=SetEncoder,
        indent=4,
    )
    json.dump(
        nx.readwrite.json_graph.node_link_data(inheritance_graph),
        open(output_dir / "inheritance_graph.json", "w"),
        cls=SetEncoder,
        indent=4,
    )
    json.dump(
        access_flags_dict,
        open(output_dir / "access_flags.json", "w")
    )
    json.dump(
        access_flags_dict,
        open(output_dir / "method_names.json", "w")
    )
    json.dump(
        final_callbacks,
        open(output_dir / "final_callbacks.json", "w"),
        cls=SetEncoder,
        indent=4,
    )

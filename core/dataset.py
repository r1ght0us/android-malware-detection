from pathlib import Path
from typing import List, Dict, Tuple, Union

import dgl
import torch
from torch.utils.data import Dataset

attributes = ['external', 'entrypoint', 'native', 'public', 'static', 'codesize']


class MalwareDataset(Dataset):
    def __init__(
            self,
            source_dir: Union[str, Path],
            samples: List[str],
            labels: Dict[str, int],
    ):
        self.source_dir = Path(source_dir)
        self.samples = samples
        self.labels = labels

    def __len__(self) -> int:
        """Denotes the total number of samples"""
        return len(self.samples)

    def _transform_names(self, graph: dgl.DGLHeteroGraph) -> dgl.DGLHeteroGraph:
        name_mapping = {
            # FCG edge mapping
            ('method', 'calls', 'method'): ('method', 'invokes', 'method'),
            ('method', 'calls', 'api_method'): ('method', 'invokes_api', 'api_method'),
            ('api_method', 'calls', 'api_method'): ('api_method', 'callback', 'api_method'),
            ('method', 'parent_of', 'method'): ('method', 'parent_of', 'method'),  # override by
            ('api_method', 'parent_of', 'method'): ('api_method', 'parent_of_user', 'method'),
            ('api_method', 'parent_of', 'api_method'): ('api_method', 'parent_of_api', 'api_method'),
            ('permission', 'used_by', 'api_method'): ('permission', 'used_by', 'api_method'),
            # RFCG edge mapping
            ('class', 'calls', 'class'): ('class', 'invokes', 'class'),
            ('class', 'calls', 'api_class'): ('class', 'invokes_api', 'api_class'),
            ('api_class', 'calls', 'api_class'): ('api_class', 'callback', 'api_class'),
            ('class', 'parent_of', 'class'): ('class', 'parent_of', 'class'),  # extends or implements
            ('api_class', 'parent_of', 'class'): ('api_class', 'parent_of_user', 'class'),
            ('api_class', 'parent_of', 'api_class'): ('api_class', 'parent_of_api', 'api_class'),
            ('permission', 'used_by', 'api_class'): ('permission', 'used_by', 'api_class'),
        }
        result_dict = {}
        for edge_type in graph.canonical_etypes:
            result_dict[name_mapping[edge_type]] = graph.all_edges(etype=edge_type)
        new_graph = dgl.heterograph(result_dict)
        new_graph.ndata['features'] = graph.ndata['features']
        return new_graph

    def __getitem__(self, index: int) -> Tuple[dgl.DGLHeteroGraph, int]:
        """Generates one sample of data"""
        name = self.samples[index]
        graphs, _ = dgl.data.utils.load_graphs(str(self.source_dir / name))
        graph = self._transform_names(graphs[0])
        api_node_name = 'api_method' if '.fcg' in name else 'api_class'
        user_node_name = 'method' if '.fcg' in name else 'class'
        if api_node_name not in graph.ndata['features']:
            api_node_count = graph.num_nodes(api_node_name)
            api_node_features = {api_node_name: torch.zeros(api_node_count)}
            graph.ndata['features'] = {**api_node_features, **graph.ndata['features']}
        if user_node_name not in graph.ndata['features']:
            user_node_count = graph.num_nodes(user_node_name)
            user_node_features = {user_node_name: torch.zeros(user_node_count, 21, dtype=torch.int16)}
            graph.ndata['features'] = {**user_node_features, **graph.ndata['features']}
        if 'permission' not in graph.ndata['features']:
            permission_node_count = graph.num_nodes('permission')
            permission_node_features = {'permission': 177 * torch.ones(permission_node_count, dtype=torch.float32)}
            graph.ndata['features'] = {**permission_node_features, **graph.ndata['features']}
        return graph, self.labels[name]
